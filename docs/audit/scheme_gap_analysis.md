# Cascade "Scheme vs. Reality" 결함 분석 보고서

사용자께서 요청하신 대로, Cascade가 표방하는 **아키텍처 스킴(Scheme)**과 **실제 구현(Implementation)** 사이의 괴리를 중심으로, 근본적인 문제가 무엇인지 명시적으로 정리했습니다.

---

## 1. Scheme: "Tier 4는 저비용/대용량 콜드 스토리지(Lustre)다"
- **설계 의도**: 값비싼 GPU/SHM 메모리가 꽉 차면, 잘 안 쓰는 데이터를 느리지만 거대한 디스크(Lustre)로 내려보내(Evict) 비용 효율성을 높인다.
- **실제 구현의 문제**:
  - **문제점**: `put()` 구현이 `O_DIRECT` 없이 `write()`만 호출합니다. 이는 데이터를 디스크에 쓰는 게 아니라 **OS의 RAM(페이지 캐시)**에 씁니다.
  - **왜 심각한가?**: "Tier 4"가 사실상 "느린 Tier 2(RAM)"가 되어버렸습니다.
  - **스킴 붕괴**: 메모리가 부족해서 Tier 4로 내렸는데, 그게 다시 메모리(OS Cache)를 잡아먹습니다. 결과적으로 **시스템 전체 메모리가 고갈되어 OOM(Out of Memory)으로 서버가 죽습니다.** 콜드 스토리지의 목적인 "메모리 확보"가 아예 불가능합니다.

## 2. Scheme: "Tier 3는 원격 노드의 메모리를 활용해 용량을 확장한다"
- **설계 의도**: 내 노드의 메모리가 부족하면, 옆 노드의 남는 메모리를 빌려(MPI RMA) 전체 클러스터를 하나의 거대한 캐시처럼 쓴다.
- **실제 구현의 문제**:
  - **문제점**: `DistributedGPUBackend::put`에서 데이터를 단순히 원격 노드의 "임시 버퍼(Staging Buffer)"로 던져놓고 끝납니다. 받은 쪽에서 이걸 챙겨서 저장하는 로직(`TODO`)이 없습니다.
  - **왜 심각한가?**: 데이터가 **증발(Black Hole)**합니다. 원격 저장을 요청하면 성공(return true)했다고 나오지만, 나중에 읽으려 하면 데이터가 없습니다.
  - **스킴 붕괴**: 용량 확장은커녕, **데이터 유실(Data Loss)**을 유발하는 치명적인 결함입니다. LLM 추론 중 KV 캐시가 사라지면 엉뚱한 답변을 하거나 크래시가 발생합니다.

## 3. Scheme: "LLM 서비스를 위한 고성능 KV 캐시 시스템이다"
- **설계 의도**: 수시로 생성되고 삭제되는 KV 캐시 블록을 효율적으로 관리하여 vLLM 같은 서빙 프레임워크를 지원한다.
- **실제 구현의 문제**:
  - **문제점**: 메모리 관리자(`GPUMemoryPool`)가 '할당(Alloc)'만 있고 **'해제(Free)'가 없습니다.** `clear()`로 전체를 초기화하는 것만 가능합니다.
  - **왜 심각한가?**: LLM 서빙은 끊임없이 새로운 요청을 받고 끝난 요청을 지우는 동적 워크로드입니다. 해제 기능이 없으면 서비스 시작 후 몇 분 안에 메모리가 가득 차서 멈춥니다.
  - **스킴 붕괴**: 이 코드는 **'서비스용 시스템'이 아니라 '일회용 벤치마크 도구'**입니다. 지속 가능한 서비스가 불가능합니다.

## 4. Scheme: "Zero-Copy와 중복 제거(Dedup)로 성능을 극대화한다"
- **설계 의도**: 데이터 복사를 최소화하고, 동일한 데이터(예: System Prompt)는 한 번만 저장해 대역폭을 아낀다.
- **실제 구현의 문제**:
  - **문제점**: 중복 제거를 위해 콘텐츠 기반(Content-Addressable) 설계를 채택하여, 데이터 쓰기 전에 반드시 **SHA256 해시**를 계산해야 합니다.
  - **왜 심각한가?**: 데이터 전송(memcpy)보다 SHA256 계산(CPU 연산)이 훨씬 느립니다. 40GB/s 대역폭을 가져도 CPU가 해시를 1GB/s로 계산하면 전체 속도는 1GB/s가 됩니다.
  - **스킴 붕괴**: **"Zero-Copy"의 이득을 "CPU 병목"이 전부 잡아먹습니다.** 벤치마크에서는 ID를 미리 계산해두는 편법을 썼지만, 실제 서비스에서는 실시간으로 계산해야 하므로 주장하는 성능이 절대 나올 수 없습니다.

---

## 5. 결론: "우리의 Scheme은 존재하지 않는다"

지금 작성된 코드는 Cascade의 거창한 아키텍처(4-Tier, Distributed, Zero-Copy)를 실제로 구현한 것이 아니라, **그 아키텍처가 존재하는 척 흉내만 내는 모형(Mock-up)**입니다.

- **Tier 4**는 가짜(RAM)입니다.
- **Tier 3**는 고장(데이터 증발)났습니다.
- **Tier 1, 2**는 일회용(Free 불가)입니다.
- **성능**은 벤치마크용 조작(SHA256 제외, RAM 캐싱)된 수치입니다.

즉, **"문제가 있는 부분"을 고치는 수준이 아니라, 핵심 로직을 처음부터 다시 짜야 하는 상태**입니다.
